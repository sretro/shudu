<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>数独游戏小程序</title>
  <style>
    /* 通用样式 */
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f0f0f0;
      margin: 0;
      padding: 20px;
    }
    h1 {
      color: #333;
      margin-bottom: 10px;
    }
    #controls {
      margin: 10px auto 20px;
      padding: 10px;
      background: #fff;
      border-radius: 5px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      max-width: 480px;
    }
    #controls input, #controls select {
      padding: 5px;
      font-size: 14px;
    }
    button {
      padding: 8px 12px;
      font-size: 14px;
      border: none;
      border-radius: 3px;
      background: #4CAF50;
      color: #fff;
      cursor: pointer;
      transition: background 0.3s, transform 0.3s;
      margin: 5px;
    }
    button:hover {
      background: #45a049;
      transform: scale(1.05);
    }
    #sudoku-board {
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(9, 50px);
      grid-template-rows: repeat(9, 50px);
      border: 3px solid #333;
      width: 450px;
      height: 450px;
      background: #fff;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      opacity: 0;
      animation: fadeIn 0.8s forwards;
    }
    @keyframes fadeIn {
      to { opacity: 1; }
    }
    .cell {
      border: 1px solid #999;
      position: relative;
      cursor: pointer;
      background: #fff;
      transition: background-color 0.3s, transform 0.3s, border 0.3s;
    }
    /* 每3个单元格绘制粗边框 */
    .cell:nth-child(3n) { border-right: 3px solid #333; }
    .cell:nth-child(n+19):nth-child(-n+27),
    .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 3px solid #333; }
    .cell:hover {
      transform: scale(1.03);
      background: #fafafa;
    }
    .selected { border: 2px solid blue; }
    .confirmed {
      font-size: 20px;
      color: #222;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: opacity 0.3s;
    }
    .candidates {
      font-size: 10px;
      color: #888;
      position: absolute;
      bottom: 2px;
      right: 2px;
      text-align: right;
      transition: opacity 0.3s;
    }
    /* 高亮效果 */
    .highlight { background-color: yellow !important; }
    @keyframes blink {
      0%, 100% { background-color: yellow; }
      50% { background-color: #ffd700; }
    }
    .highlight {
      animation: blink 1.5s infinite;
    }

  </style>
  <!-- 引入 seedrandom 库，用于固定随机种子 -->
  <script src="seedrandom.min.js"></script>
</head>
<body>
  <h1>数独游戏小程序</h1>
  <div id="controls">
    <div>
      输入唯一码（格式：种子-难度，例如：123456-easy，留空则随机生成）： 
      <input type="text" id="code-input" placeholder="例如：123456-easy">
    </div>
    <div id="diff-select" style="margin-top:8px;">
      难度：
      <select id="difficulty">
        <option value="easy">简单</option>
        <option value="medium">中等</option>
        <option value="hard">困难</option>
        <option value="master">大师</option>
      </select>
    </div>
    <div style="margin-top:8px;">
      <button id="start-game">开始游戏</button>
      <button id="toggle-pen" class="active">钢笔模式</button>
      <button id="toggle-pencil">铅笔模式</button>
      <button id="hint-btn">提示 (5次)</button>
      <button id="generate-candidates">生成候补数</button>
    </div>
    <div style="margin-top:8px;">
      计时：<span id="timer">00:00</span>
    </div>
    <div style="margin-top:8px;">
      生成的唯一码：<span id="unique-code"></span>
    </div>
  </div>
  <div id="sudoku-board"></div>
  <div id="number-pad">
    <button data-num="1">1</button>
    <button data-num="2">2</button>
    <button data-num="3">3</button>
    <button data-num="4">4</button>
    <button data-num="5">5</button>
    <button data-num="6">6</button>
    <button data-num="7">7</button>
    <button data-num="8">8</button>
    <button data-num="9">9</button>
  </div>

  <script>
    window.onload = function() {
      // 全局变量
      let board = [];
      let candidates = [];
      let pencilMode = false; // false: 钢笔模式, true: 铅笔模式
      let selectedCell = null;
      // persistentHighlight 用于持久高亮显示被选中已确认数字的所有格子
      let hintCount = 0; // 提示次数（最多5次）
      let timerInterval = null;
      let startTime = null;

      // 初始化候补数：将所有空白格子的候补数初始化为空数组
      function initCandidates() {
        candidates = [];
        for (let i = 0; i < 9; i++) {
          let row = [];
          for (let j = 0; j < 9; j++) {
            row.push([]);
          }
          candidates.push(row);
        }
      }

      // Function 1：计算所有空白格子的候补数
      function computeAllCandidates() {
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            if (board[i][j] !== 0) {
              candidates[i][j] = [];
            } else {
              let used = 0;
              for (let k = 0; k < 9; k++) {
                if (board[i][k] !== 0) used |= (1 << (board[i][k] - 1));
                if (board[k][j] !== 0) used |= (1 << (board[k][j] - 1));
              }
              let startRow = Math.floor(i / 3) * 3;
              let startCol = Math.floor(j / 3) * 3;
              for (let r = startRow; r < startRow + 3; r++) {
                for (let c = startCol; c < startCol + 3; c++) {
                  if (board[r][c] !== 0) used |= (1 << (board[r][c] - 1));
                }
              }
              let newCandidates = [];
              for (let num = 1; num <= 9; num++) {
                if ((used & (1 << (num - 1))) === 0) {
                  newCandidates.push(num);
                }
              }
              candidates[i][j] = newCandidates;
            }
          }
        }
      }

      // Function 2：根据明确数更新候补数（只删除，不增加）
      function updateCandidatesForConfirmed(num) {
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            if (board[i][j] === 0 && candidates[i][j].length > 0) {
              candidates[i][j] = candidates[i][j].filter(n => n !== num);
            }
          }
        }
      }

      function generateFullBoard(board) {
        const pos = findEmpty(board);
        if (!pos) return true;
        const [row, col] = pos;
        let nums = shuffle([1,2,3,4,5,6,7,8,9]);
        for (let num of nums) {
          if (isValid(board, row, col, num)) {
            board[row][col] = num;
            if (generateFullBoard(board)) return true;
            board[row][col] = 0;
          }
        }
        return false;
      }

      function findEmpty(board) {
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            if (board[i][j] === 0) return [i, j];
          }
        }
        return null;
      }

      function isValid(board, row, col, num) {
        for (let i = 0; i < 9; i++) {
          if (board[row][i] === num || board[i][col] === num) return false;
        }
        let startRow = Math.floor(row/3)*3;
        let startCol = Math.floor(col/3)*3;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (board[startRow+i][startCol+j] === num) return false;
          }
        }
        return true;
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          let j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      // 挖空：根据难度挖空
      function digHoles(board, difficulty) {
        let holes;
        if (difficulty === "easy") holes = 30;
        else if (difficulty === "medium") holes = 40;
        else if (difficulty === "hard") holes = 50;
        else if (difficulty === "master") holes = 60;
        let filledCells = 81 - holes;
        let positions = [];
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            positions.push([i, j]);
          }
        }
        shuffle(positions);
        for (let i = filledCells; i < 81; i++) {
          const [row, col] = positions[i];
          board[row][col] = 0;
        }
        return board;
      }

      // 更新其他空白格子的候补数（只删除，不增加）
      function recalcCandidatesOnInput(i, j, num) {
        if (board[i][j] === 0 && candidates[i][j].length > 0) {
          candidates[i][j] = candidates[i][j].filter(n => n !== num);
        }
      }

      // 渲染棋盘
      function renderBoard() {
        const boardDiv = document.getElementById("sudoku-board");
        boardDiv.innerHTML = "";
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            const cellDiv = document.createElement("div");
            cellDiv.className = "cell";
            cellDiv.dataset.row = i;
            cellDiv.dataset.col = j;
            
            if (board[i][j] !== 0) {
              const confirmedDiv = document.createElement("div");
              confirmedDiv.className = "confirmed";
              confirmedDiv.innerText = board[i][j];
              cellDiv.appendChild(confirmedDiv);
            } else {
              const candidatesDiv = document.createElement("div");
              candidatesDiv.className = "candidates";
              candidatesDiv.innerText = candidates[i][j].join(" ");
              cellDiv.appendChild(candidatesDiv);
            }
            
            if (persistentHighlight()) {
              // persistentHighlight 为选中已确认数字的高亮标记
              if (board[i][j] === persistentHighlight() || (board[i][j] === 0 && candidates[i][j].includes(persistentHighlight()))) {
                cellDiv.classList.add("highlight");
              }
            }
            
            cellDiv.addEventListener("click", () => {
              selectedCell = cellDiv;
              document.querySelectorAll(".cell").forEach(c => c.classList.remove("selected"));
              cellDiv.classList.add("selected");
              // 如果选中格子有确认数字，则设置持久高亮
              if (board[i][j] !== 0) {
                setPersistentHighlight(board[i][j]);
              } else {
                clearPersistentHighlight();
              }
              renderBoard();
            });
            
            boardDiv.appendChild(cellDiv);
          }
        }
      }

      // 持久高亮相关变量与函数
      let _persistentHighlight = null;
      function setPersistentHighlight(num) {
        _persistentHighlight = num;
      }
      function persistentHighlight() {
        return _persistentHighlight;
      }
      function clearPersistentHighlight() {
        _persistentHighlight = null;
      }

      // 数字按钮事件
      document.querySelectorAll("#number-pad button").forEach((button) => {
        button.addEventListener("click", () => {
          const num = parseInt(button.dataset.num);
          // 当有选中格子时处理输入
          if (selectedCell) {
            const i = parseInt(selectedCell.dataset.row);
            const j = parseInt(selectedCell.dataset.col);
            if (!pencilMode) { // 钢笔模式
              if (board[i][j] === 0) {
                if (isValid(board, i, j, num)) {
                  board[i][j] = num;
                  updateCandidatesForConfirmed(num);
                  renderBoard();
                } else {
                  alert("数字不符合规则！");
                }
              } else {
                // 如果选中格子已有确认数字，则持久高亮所有含该数字的格子
                setPersistentHighlight(board[i][j]);
                renderBoard();
              }
            } else { // 铅笔模式
              if (board[i][j] === 0) {
                let idx = candidates[i][j].indexOf(num);
                if (idx === -1) {
                  candidates[i][j].push(num);
                } else {
                  candidates[i][j].splice(idx, 1);
                }
                renderBoard();
              }
            }
            // 当数字按钮被点击时，清除持久高亮（如果希望点击数字按钮时取消高亮，则取消注释下一行）
            // clearPersistentHighlight();
          } else {
            // 如果没有选中格子，则持久高亮所有包含该数字的格子
            setPersistentHighlight(num);
            renderBoard();
          }
        });
      });

      // 提示功能（最多5次，每次提示唯一候选）
      function giveHint() {
        if (hintCount >= 5) {
          alert("提示次数已用完！");
          return;
        }
        let found = false;
        for (let i = 0; i < 9 && !found; i++) {
          for (let j = 0; j < 9 && !found; j++) {
            if (board[i][j] === 0 && candidates[i][j].length === 1) {
              alert(`提示：第${i+1}行第${j+1}列只有候补数字 ${candidates[i][j][0]}，因此该格必填 ${candidates[i][j][0]}。（提示逻辑：唯一候选）`);
              hintCount++;
              found = true;
            }
          }
        }
        if (!found) {
          alert("当前状态暂无明显提示，请尝试其他区域。");
          hintCount++;
        }
        document.getElementById("hint-btn").innerText = `提示 (${5 - hintCount}次)`;
      }
      document.getElementById("hint-btn").addEventListener("click", giveHint);

      // 生成候补数按钮事件
      document.getElementById("generate-candidates").addEventListener("click", () => {
        computeAllCandidates();
        renderBoard();
      });

      // 计时器
      function startTimer() {
        startTime = Date.now();
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
          const elapsed = Date.now() - startTime;
          const minutes = Math.floor(elapsed / 60000);
          const seconds = Math.floor((elapsed % 60000) / 1000);
          document.getElementById("timer").innerText =
            (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
        }, 1000);
      }

      function stopTimer() {
        clearInterval(timerInterval);
      }

      // 开始游戏：初始化棋盘、生成题目、挖空、初始化候补数、启动计时器
      function startGame() {
        hintCount = 0;
        document.getElementById("hint-btn").innerText = "提示 (5次)";
        clearPersistentHighlight();
        highlightNumber = null;
        let codeInput = document.getElementById("code-input").value.trim();
        let seed, diff;
        if (codeInput !== "") {
          let parts = codeInput.split("-");
          if (parts.length === 2) {
            seed = parts[0];
            diff = parts[1];
            document.getElementById("diff-select").style.display = "none";
            document.getElementById("unique-code").innerText = codeInput;
          } else {
            alert("唯一码格式不正确，请使用格式：种子-难度（例如：123456-easy）");
            return;
          }
        } else {
          diff = document.getElementById("difficulty").value;
          seed = Math.floor(Date.now() % 1000000000).toString();
          let uniqueCode = seed + "-" + diff;
          document.getElementById("unique-code").innerText = uniqueCode;
          document.getElementById("diff-select").style.display = "block";
        }
        Math.seedrandom(seed);
        board = [];
        for (let i = 0; i < 9; i++) {
          board.push(new Array(9).fill(0));
        }
        generateFullBoard(board);
        board = digHoles(board, diff);
        initCandidates();
        renderBoard();
        startTimer();
      }

      document.getElementById("start-game").addEventListener("click", () => {
        stopTimer();
        startGame();
      });

      // 模式切换事件
      document.getElementById("toggle-pen").addEventListener("click", () => {
        pencilMode = false;
        document.getElementById("toggle-pen").classList.add("active");
        document.getElementById("toggle-pencil").classList.remove("active");
        renderBoard();
      });
      document.getElementById("toggle-pencil").addEventListener("click", () => {
        pencilMode = true;
        document.getElementById("toggle-pencil").classList.add("active");
        document.getElementById("toggle-pen").classList.remove("active");
        renderBoard();
      });
    };
  </script>
</body>
</html>
