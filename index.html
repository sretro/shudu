<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Sudoku - 你是大师啊？</title>
  <script src="https://cdn.jsdelivr.net/npm/seedrandom/dist/seedrandom.min.js"></script>
  <style>
    :root {
      --bg-color: #1a1a1a;
      --card-bg: #242424;
      --primary-color: #ffd700;
      --primary-dark: #b39700;
      --accent-color: #c0962f;
      --error-color: #ff4444;
      --success-color: #4caf50;
      --text-color: #ffffff;
      --border-color: #333333;
      --control-bg: #2a2a2a;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Microsoft YaHei", sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      margin: 0;
      width: 100%;
      overflow-x: hidden; /* 防止水平滚动 */
    }
    header {
      text-align: center; padding: 15px; background: linear-gradient(to bottom, #2a2a2a, var(--card-bg));
      border-bottom: 2px solid var(--primary-color); margin-bottom: 10px;
    }
    header h1 { font-size: 1.8rem; color: var(--primary-color); text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
    .game-container {
      display: flex;
      flex-direction: column;
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      gap: 10px; /* 统一控制各区块间距 */
    }
    .top-controls {
      padding: 10px;
    }
    .board-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
    }
    .sudoku-board {
      width: min(800px, 90vw); /* 固定最大宽度为800px */
      height: min(800px, 90vw); /* 保持正方形 */
      background: var(--card-bg);
      border: 2px solid var(--primary-color);
      border-radius: 8px;
      border-collapse: collapse;
    }
    .sudoku-board td {
      border: 1px solid var(--border-color);
      position: relative;
      text-align: center;
      vertical-align: middle;
      font-size: 48px; /* 增大主数字大小 */
      font-weight: bold;
      width: 88px; /* 固定格子大小 ~= 800/9 */
      height: 88px;
      max-width: 88px;
      max-height: 88px;
    }
    .sudoku-board tr:nth-child(3n) td {
      border-bottom: 2px solid var(--primary-color);
    }
    .sudoku-board td:nth-child(3n) {
      border-right: 2px solid var(--primary-color);
    }
    .bottom-controls {
      background: var(--control-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 8px;
      margin: 10px auto;
      max-width: 800px;
      position: relative;
      z-index: 1;
    }
    .input-controls {
      max-width: 600px; /* 控制数字键盘宽度 */
      margin: 0 auto;
    }
    .mode-group {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .mode-group label {
      padding: 4px 12px;
      font-size: 14px;
    }
    .number-input {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 4px;
    }
    .num-btn {
      aspect-ratio: 1;
      font-size: 16px;
      padding: 0;
      min-width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }
    .candidate {
      font-size: 24px; /* 增大候选数字大小 */
      color: var(--text-color);
      opacity: 0.7;
      line-height: 1.3;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      padding: 4px;
    }
    .controls {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 10px; width: 100%;
    }
    .control-block {
      background: var(--control-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .control-block h2 {
      font-size: 1rem; margin-bottom: 10px; color: var(--primary-color); border-bottom: 1px solid var(--border-color); padding-bottom: 5px;
    }
    .game-settings {
      display: flex; gap: 10px; flex-wrap: wrap;
    }
    .difficulty-group {
      display: flex; gap: 8px; flex-wrap: wrap;
    }
    .difficulty-group label {
      background: var(--card-bg);
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      cursor: pointer;
      transition: all 0.2s;
    }
    .difficulty-group label:hover {
      border-color: var(--primary-color);
    }
    .difficulty-group input[type="radio"] {
      display: none;
    }
    .difficulty-group input[type="radio"]:checked + label {
      background: var(--primary-color);
      color: var(--bg-color);
      border-color: var(--primary-color);
    }
    .game-tools {
      display: flex; gap: 8px; flex-wrap: wrap;
    }
    .game-tools .btn {
      background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
      color: var(--text-color);
      padding: 8px 16px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      font-weight: bold;
    }
    .game-tools .btn:hover {
      background: var(--primary-color);
      color: var(--bg-color);
      border-color: var(--primary-dark);
    }
    .selected-cell {
      background-color: rgba(255, 215, 0, 0.2) !important;
      border: 2px solid var(--primary-color) !important;
    }
    .highlight {
      background-color: rgba(255, 215, 0, 0.1) !important;
    }
    .message {
      background: var(--control-bg);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px;
      margin-top: 8px;
    }
    footer {
      text-align: center; padding: 10px; background: var(--card-bg); color: #666; border-top: 1px solid var(--border-color);
    }
    @media (max-width: 768px) {
      .game-container {
        gap: 10px; /* 移动端减小间距 */
      }
      .top-controls {
        padding: 0; /* 移除顶部内边距 */
      }
      .board-area {
        padding: 5px 0; /* 减小棋盘区域上下内边距 */
      }
      .bottom-controls {
        margin: 5px auto; /* 减小底部控制区域外边距 */
      }
      .control-block {
        padding: 10px; /* 减小控制块内边距 */
      }
      .number-input {
        grid-template-columns: repeat(3, 1fr);
      }
      .btn {
        padding: 10px;
        font-size: 0.9rem;
      }
      .number-input {
        gap: 3px;
      }
      .num-btn {
        font-size: 1rem;
      }
      .mode-group label {
        padding: 6px 12px;
        font-size: 0.9rem;
      }
      .sudoku-board {
        width: min(360px, 90vw); /* 移动端回到较小尺寸 */
        height: min(360px, 90vw);
      }
      
      .sudoku-board td {
        width: 40px;
        height: 40px;
        max-width: 40px;
        max-height: 40px;
        font-size: 24px;
      }
      
      .candidate {
        font-size: 12px;
      }
      
      .num-btn {
        min-width: 28px;
        height: 28px;
        font-size: 14px;
      }
      
      .mode-group label {
        padding: 3px 10px;
        font-size: 13px;
      }
      .bottom-controls {
        max-width: 360px;
        padding: 6px;
      }
    }
    .message.error {
      color: var(--error-color);
      margin-top: 8px;
    }
    .message.success {
      color: var(--success-color);
      margin-top: 8px;
    }
  </style>
    <script src="seedrandom.min.js"></script>

</head>
<body>

<header>
  <h1>Sudoku - 你叫大师啊？</h1>
</header>

<div class="game-container">
  <!-- 顶部控制区 -->
  <div class="top-controls">
    <div class="control-block">
      <div class="game-settings">
        <div class="difficulty-group">
          <input type="radio" name="difficulty" id="easy" value="easy" checked>
          <label for="easy">简单</label>
          <input type="radio" name="difficulty" id="medium" value="medium">
          <label for="medium">中级</label>
          <input type="radio" name="difficulty" id="hard" value="hard">
          <label for="hard">困难</label>
          <input type="radio" name="difficulty" id="master" value="master">
          <label for="master">大师</label>
        </div>
        <input type="text" id="seed-input" placeholder="输入6位种子" class="btn">
        <button class="btn" id="start-game">开始游戏</button>
        <button class="btn" id="fill-candidates">补全候选</button>
        <button class="btn" id="btn-hint">提示</button>
        <div class="message error" id="error-info"></div>
        <div class="message success" id="success-info"></div>
        <div class="message" id="hint-msg"></div>
      </div>
    </div>
  </div>

  <!-- 棋盘区域 -->
  <div class="board-area">
    <table class="sudoku-board" id="sudoku-board"></table>
  </div>

  <!-- 底部控制区 -->
  <div class="bottom-controls">
    <div class="input-controls">
      <div class="mode-group">
        <input type="radio" name="mode" id="pen" value="pen" checked>
        <label for="pen">钢笔</label>
        <input type="radio" name="mode" id="pencil" value="pencil">
        <label for="pencil">铅笔</label>
      </div>
      <div class="number-input">
        <button class="btn num-btn" data-num="1">1</button>
        <button class="btn num-btn" data-num="2">2</button>
        <button class="btn num-btn" data-num="3">3</button>
        <button class="btn num-btn" data-num="4">4</button>
        <button class="btn num-btn" data-num="5">5</button>
        <button class="btn num-btn" data-num="6">6</button>
        <button class="btn num-btn" data-num="7">7</button>
        <button class="btn num-btn" data-num="8">8</button>
        <button class="btn num-btn" data-num="9">9</button>
      </div>
    </div>
  </div>
</div>

<footer>Sudoku Demo &copy; 2025</footer>

<script>
/**************************************************************
 * 1. 全局变量、数据结构
 **************************************************************/
let solutionGrid = [];
let puzzleGrid = [];
// candidatesGrid[r][c] = Set(数字) => 当前"已展示"的候选
let candidatesGrid = [];
let selectedCell = null;
let errorCount = 0;
const maxErrors = 4;
let rng = Math.random;
// 在全局定义一个变量记录上一次提示
let lastHint = null;
let currentHighlightNum = null;

/** 种子：1位难度(0~3) + 5位随机数(00001~99999) => 6位 */
const difficultyMap = { easy:"0", medium:"1", hard:"2", master:"3" };
const difficultyMapReverse = { "0":"easy", "1":"medium", "2":"hard", "3":"master" };

const sudokuBoard = document.getElementById('sudoku-board');
const seedInput = document.getElementById('seed-input');
const errorInfo = document.getElementById('error-info');
const successInfo = document.getElementById('success-info');

/**************************************************************
 * 2. 核心数独(回溯、挖空)
 **************************************************************/
function randomInt(min, max){ 
  return Math.floor(rng()*(max-min+1))+min;
}
function isValid(grid, row, col, n){
  for(let c=0;c<9;c++){
    if(grid[row][c]===n) return false;
  }
  for(let r=0;r<9;r++){
    if(grid[r][col]===n) return false;
  }
  let boxRow=Math.floor(row/3)*3, boxCol=Math.floor(col/3)*3;
  for(let rr=0; rr<3; rr++){
    for(let cc=0; cc<3; cc++){
      if(grid[boxRow+rr][boxCol+cc]===n) return false;
    }
  }
  return true;
}
function generateSolution(){
  let grid=Array.from({length:9},()=>Array(9).fill(0));
  function fillCell(r,c){
    if(r===9) return true;
    let nextR=r, nextC=c+1;
    if(nextC===9){ nextR++; nextC=0; }
    let nums=[1,2,3,4,5,6,7,8,9];
    nums.sort(()=>rng()-0.5);
    for(let n of nums){
      if(isValid(grid,r,c,n)){
        grid[r][c]=n;
        if(fillCell(nextR,nextC)) return true;
        grid[r][c]=0;
      }
    }
    return false;
  }
  fillCell(0,0);
  return grid;
}
function cloneGrid(g){ return g.map(row=>row.slice()); }
function digHoles(fullGrid, difficulty){
  let puzzle=cloneGrid(fullGrid);
  let holes;
  switch(difficulty){
    case "easy": holes=33; break;
    case "medium": holes=42; break;
    case "hard": holes=50; break;
    case "master": holes=56; break;
    default: holes=33;
  }
  while(holes>0){
    let r=randomInt(0,8), c=randomInt(0,8);
    if(puzzle[r][c]!==0){
      puzzle[r][c]=0;
      holes--;
    }
  }
  return puzzle;
}

/** 6位种子 => 第1位难度(0~3) + 5位随机数 */
function encodeSeed(difficulty, seedNumber){
  let diffCode=difficultyMap[difficulty]||"0";
  let seedStr=String(seedNumber).padStart(5,'0');
  return diffCode+seedStr;
}
function decodeSeed(s){
  if(s.length!==6) return null;
  let diffCode=s[0], seedPart=s.slice(1);
  let diff=difficultyMapReverse[diffCode];
  if(!diff) return null;
  let seedNum=parseInt(seedPart,10);
  if(isNaN(seedNum)) return null;
  return { difficulty:diff, seedNumber:seedNum };
}

/**************************************************************
 * 3. 初始化 & 界面渲染
 **************************************************************/
function createBoardCells(){
  sudokuBoard.innerHTML='';
  for(let r=0;r<9;r++){
    let tr=document.createElement('tr');
    for(let c=0;c<9;c++){
      let td=document.createElement('td');
      td.dataset.row=r;
      td.dataset.col=c;
      td.addEventListener('click', onCellClick);
      tr.appendChild(td);
    }
    sudokuBoard.appendChild(tr);
  }
}
function renderPuzzle(){
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      let td=sudokuBoard.rows[r].cells[c];
      td.classList.remove('selected-cell','highlight');
      td.innerHTML='';
      let val=puzzleGrid[r][c];
      if(val!==0){
        td.textContent=val;
        td.dataset.fixed='true';
      } else {
        td.dataset.fixed='false';
      }
    }
  }
}
function resetInfo(){
  errorCount=0;
  errorInfo.textContent='';
  successInfo.textContent='';
}
function initCandidates(){
  candidatesGrid=Array.from({length:9},()=>
    Array.from({length:9},()=> new Set())
  );
}

/**************************************************************
 * 4. 候选数的"补全" & "显示"逻辑
 **************************************************************/
function computeAllCandidates(){
  // 先清空
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      candidatesGrid[r][c].clear();
    }
  }
  // 对每个空格 => 计算所有可能数字
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      if(puzzleGrid[r][c]===0){
        let poss=new Set([1,2,3,4,5,6,7,8,9]);
        // 行
        for(let col=0;col<9;col++){
          if(puzzleGrid[r][col]!==0) poss.delete(puzzleGrid[r][col]);
        }
        // 列
        for(let row=0;row<9;row++){
          if(puzzleGrid[row][c]!==0) poss.delete(puzzleGrid[row][c]);
        }
        // 宫
        let boxR=Math.floor(r/3)*3, boxC=Math.floor(c/3)*3;
        for(let rr=0; rr<3; rr++){
          for(let cc=0; cc<3; cc++){
            let val=puzzleGrid[boxR+rr][boxC+cc];
            if(val!==0) poss.delete(val);
          }
        }
        candidatesGrid[r][c]=poss;
      }
    }
  }
}
function renderCandidates(){
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      let td=sudokuBoard.rows[r].cells[c];
      if(puzzleGrid[r][c]===0){
        // 显示 candidatesGrid[r][c]
        let set=candidatesGrid[r][c];
        if(set.size>0){
          td.innerHTML=`<div class="candidate">${[...set].join(' ')}</div>`;
        } else {
          td.innerHTML='';
        }
      }
    }
  }
}
/**************************************************************
 * 4. "点亮"功能
 **************************************************************/
/** 清除所有 highlight */
function clearAllHighlight(){
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      sudokuBoard.rows[r].cells[c].classList.remove('highlight');
    }
  }
}

/**
 * 只点亮 "实际展示" 的数字（含候选）
 * - puzzleGrid[r][c] == num => highlight
 * - 候选div里若包含该数字 => highlight
 */
function highlightCellsWithNumber(num){
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      let td=sudokuBoard.rows[r].cells[c];
      let val=puzzleGrid[r][c];
      if(val===num){
        td.classList.add('highlight');
      } else if(val===0){
        // 查看可见候选div
        let candDiv=td.querySelector('.candidate');
        if(candDiv) {
          // 将文本拆分空格，若包含num则高亮
          let textArr=candDiv.textContent.split(/\s+/);
          if(textArr.includes(String(num))){
            td.classList.add('highlight');
          }
        }
      }
    }
  }
}

/**
 * 设置当前高亮数字：
 * - 若 num===null 或 num===currentHighlightNum => 取消点亮
 * - 否则切换到新数字
 */
function setHighlightNumber(num){
  if(num===null || num===currentHighlightNum){
    clearAllHighlight();
    currentHighlightNum=null;
  } else {
    clearAllHighlight();
    highlightCellsWithNumber(num);
    currentHighlightNum=num;
  }
}
/**************************************************************
 * 5. 点击格子 & 输入数字
 **************************************************************/
function onCellClick(e){
  let td=e.currentTarget;
  if(selectedCell===td){
    // 再次点击同一个格 => 取消选中
    td.classList.remove('selected-cell');
    selectedCell=null;
    setHighlightNumber(null); 
    return;
  }
  if(selectedCell){
    selectedCell.classList.remove('selected-cell');
  }
  td.classList.add('selected-cell');
  selectedCell=td;
  let r=+td.dataset.row, c=+td.dataset.col;
  let val=puzzleGrid[r][c];
  if(val!==0){
    setHighlightNumber(val);
  } else {
    setHighlightNumber(null);
  }

}
function checkWin(){
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      if(puzzleGrid[r][c]===0) return false;
    }
  }
  return true;
}
function gameOver(){
  errorInfo.textContent='错误次数过多，游戏结束！';
  let tds=sudokuBoard.getElementsByTagName('td');
  for(let td of tds){
    td.removeEventListener('click', onCellClick);
  }
}

/** 数字输入逻辑(点击数字按钮或键盘) */
function onNumberInput(num){
  if(!selectedCell) return;
  if(selectedCell.dataset.fixed==='true') return; // 固定数字格，不能改

  let r=+selectedCell.dataset.row, c=+selectedCell.dataset.col;
  let mode=document.querySelector('input[name="mode"]:checked').value;
  if(mode==='pen'){
    // 钢笔：若有效 => 放入 puzzleGrid => 只删除相关联格子里已展示的候选
    if(isValid(puzzleGrid,r,c,num)){
      puzzleGrid[r][c]=num;
      selectedCell.textContent=num;
      selectedCell.style.color="var(--primary-color)";
      removeCandidateFromPeers(r,c,num); // 只做"删除"
      if(checkWin()){
        successInfo.textContent='恭喜完成！';
      }
    } else {
      // 错误一次
      errorCount++;
      errorInfo.textContent=`错误：${errorCount}/${maxErrors}`;
      if(errorCount>=maxErrors){
        gameOver();
      }
    }
  } else {
    // 铅笔：只对当前位置的候选集做添加/删除 => 重绘
    if(puzzleGrid[r][c]!==0) return; // 已有数则不进行铅笔操作

    let set=candidatesGrid[r][c];
    if(set.has(num)){
      set.delete(num);
    } else {
      set.add(num);
    }
    renderCandidateToCell(r,c);
  }
}

/** 钢笔输入正确数字 => 只删除 peers 里已展示的候选数 num，不添加任何东西 */
function removeCandidateFromPeers(r,c,num){
  // 同行
  for(let col=0; col<9; col++){
    if(candidatesGrid[r][col].has(num)){
      candidatesGrid[r][col].delete(num);
      renderCandidateToCell(r,col);
    }
  }
  // 同列
  for(let row=0; row<9; row++){
    if(candidatesGrid[row][c].has(num)){
      candidatesGrid[row][c].delete(num);
      renderCandidateToCell(row,c);
    }
  }
  // 同宫
  let boxR=Math.floor(r/3)*3, boxC=Math.floor(c/3)*3;
  for(let rr=0; rr<3; rr++){
    for(let cc=0; cc<3; cc++){
      let cr=boxR+rr, cc2=boxC+cc;
      if(candidatesGrid[cr][cc2].has(num)){
        candidatesGrid[cr][cc2].delete(num);
        renderCandidateToCell(cr,cc2);
      }
    }
  }
}

/** 只刷新一个格子的候选显示 */
function renderCandidateToCell(r,c){
  let td=sudokuBoard.rows[r].cells[c];
  if(puzzleGrid[r][c]===0){
    let set=candidatesGrid[r][c];
    if(set.size>0){
      td.innerHTML=`<div class="candidate">${[...set].join(' ')}</div>`;
    } else {
      td.innerHTML='';
    }
  }
}

/**************************************************************
 * 6. "开始游戏"按钮 => 6位种子 解析/生成
 **************************************************************/
document.getElementById('start-game').addEventListener('click', ()=>{
  resetInfo();
  createBoardCells();
  selectedCell=null;

  let seedVal=seedInput.value.trim();
  if(seedVal){
    // 有种子 => decode => 忽略难度单选
    let decoded=decodeSeed(seedVal);
    if(!decoded){
      alert('无效种子(6位)');
      return;
    }
    let diff=decoded.difficulty, seedNum=decoded.seedNumber;
    rng=new Math.seedrandom(String(seedNum));
    solutionGrid=generateSolution();
    puzzleGrid=digHoles(solutionGrid,diff);
  } else {
    // 无种子 => 用难度+随机 => 反写
    let diff=document.querySelector('input[name="difficulty"]:checked').value;
    let randomSeedNum=randomInt(1,99999);
    rng=new Math.seedrandom(String(randomSeedNum));
    solutionGrid=generateSolution();
    puzzleGrid=digHoles(solutionGrid,diff);
    let finalSeed=encodeSeed(diff,randomSeedNum);
    seedInput.value=finalSeed;
  }

  renderPuzzle();
  initCandidates();
});

/**************************************************************
 * 2. 提示：统一入口 getHint()
 * 依次检测多种技巧 => 返回第一条提示
 **************************************************************/
function getHint() {
  let res;

  // 1) Naked Single
  res = findNakedSingle();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 2) Hidden Single
  res = findHiddenSingle();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 3) Naked Pair / Triple
  res = findNakedPairOrTriple();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 4) Hidden Pair / Triple
  res = findHiddenPairOrTriple();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 5) Box-Line 排除 (Pointing Pairs)
  res = findBoxLineElimination();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 6) X-Wing
  res = findXWing();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 7) XY-Wing
  res = findXYWing();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 8) Swordfish
  res = findSwordfish();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 9) Jellyfish
  res = findJellyfish();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 10) XYZ-Wing
  res = findXYZWing();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 11) ALS
  res = findALS();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 12) DoubleChains / Multi-Coloring / ...
  res = findDoubleChains();
  if (res && !isSameHint(res, lastHint)) {
    lastHint = res;
    return res;
  }

  // 如果全部技巧都检测完了，还没有新的提示 => 返回null
  return null;
}
function isSameHint(h1, h2) {
  if (!h1 || !h2) return false;
  if (h1.technique !== h2.technique) return false;
  // 若有digit就比digit
  if ((h1.digit || -1) !== (h2.digit || -1)) return false;
  // 对比cells(若有)
  if (h1.cells && h2.cells) {
    if (h1.cells.length !== h2.cells.length) return false;
    for (let i = 0; i < h1.cells.length; i++) {
      let a = h1.cells[i], b = h2.cells[i];
      if (a.r !== b.r || a.c !== b.c) return false;
    }
  } else {
    // 若一个有cells另一个没有
    if (h1.cells || h2.cells) return false;
  }
  // 可以再比 lines, columns, etc. 视情况而定
  return true;
}

/**************************************************************
 * 2.1 Naked Single
 **************************************************************/
function findNakedSingle(){
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      if(puzzleGrid[r][c]===0){
        let cand=candidatesGrid[r][c];
        if(cand.size===1){
          let val=[...cand][0];
          return {
            technique: "Naked Single",
            message: `第${r+1}行, 第${c+1}列 只有一个候选数 ${val}`,
            cells:[{r,c}],
            digit: val
          };
        }
      }
    }
  }
  return null;
}

/**************************************************************
 * 2.2 Hidden Single
 **************************************************************/
function findHiddenSingle(){
  // 行
  for(let r=0;r<9;r++){
    let digitPositions={};
    for(let d=1; d<=9; d++){
      digitPositions[d]=[];
    }
    // 收集
    for(let c=0;c<9;c++){
      if(puzzleGrid[r][c]===0){
        for(let d of candidatesGrid[r][c]){
          digitPositions[d].push({r,c});
        }
      }
    }
    for(let d=1;d<=9;d++){
      if(digitPositions[d].length===1){
        let pos = digitPositions[d][0];
        return {
          technique: "Hidden Single",
          message: `第${r+1}行只有一个格可放数字${d}`,
          cells:[pos],
          digit:d
        };
      }
    }
  }
  // 列
  for(let c=0;c<9;c++){
    let digitPositions={};
    for(let d=1; d<=9; d++){
      digitPositions[d]=[];
    }
    for(let r=0;r<9;r++){
      if(puzzleGrid[r][c]===0){
        for(let d of candidatesGrid[r][c]){
          digitPositions[d].push({r,c});
        }
      }
    }
    for(let d=1;d<=9;d++){
      if(digitPositions[d].length===1){
        let pos=digitPositions[d][0];
        return {
          technique:"Hidden Single",
          message:`第${c+1}列只有一个格可放数字${d}`,
          cells:[pos],
          digit:d
        };
      }
    }
  }
  // 宫
  for(let boxR=0;boxR<3;boxR++){
    for(let boxC=0;boxC<3;boxC++){
      let startR=boxR*3, startC=boxC*3;
      let digitPositions={};
      for(let d=1;d<=9;d++){ digitPositions[d]=[]; }
      for(let rr=0; rr<3; rr++){
        for(let cc=0; cc<3; cc++){
          let r=startR+rr, c=startC+cc;
          if(puzzleGrid[r][c]===0){
            for(let d of candidatesGrid[r][c]){
              digitPositions[d].push({r,c});
            }
          }
        }
      }
      for(let d=1; d<=9; d++){
        if(digitPositions[d].length===1){
          let pos=digitPositions[d][0];
          return {
            technique:"Hidden Single",
            message:`在第${boxR+1}宫, 数字${d}只能放在(r${pos.r+1}, c${pos.c+1})`,
            cells:[pos],
            digit:d
          };
        }
      }
    }
  }
  return null;
}


/**************************************************************
 * 2.3 Naked Pair / Naked Triple
 **************************************************************/
function findNakedPairOrTriple(){
  // 简化：只示范行内"Naked Pair/Triple"
  // 列/宫类似逻辑
  for(let r=0;r<9;r++){
    // 收集空格 => candidates
    let empties=[];
    for(let c=0;c<9;c++){
      if(puzzleGrid[r][c]===0){
        empties.push({r,c, cands: candidatesGrid[r][c]});
      }
    }
    // 检测 Pair
    for(let i=0;i<empties.length-1;i++){
      for(let j=i+1;j<empties.length;j++){
        let set1=empties[i].cands, set2=empties[j].cands;
        // Naked Pair => 2个格的候选完全相同且size=2
        if(set1.size===2 && areSetsEqual(set1,set2)){
          // 其他格可排除这2个数字
          let digits=[...set1];
          return {
            technique:"Naked Pair",
            message:`第${r+1}行发现Naked Pair {${digits.join(',')}}`,
            cells:[{r:empties[i].r,c:empties[i].c},{r:empties[j].r,c:empties[j].c}],
            digits:digits
          };
        }
      }
    }
    // 检测 Triple => size=3, 并恰好有3个格候选集合相同
    // ...省略更多复杂逻辑
  }
  return null;
}

function areSetsEqual(s1, s2){
  if(s1.size!==s2.size) return false;
  for(let x of s1){
    if(!s2.has(x)) return false;
  }
  return true;
}

/**************************************************************
 * 2.4 Hidden Pair / Hidden Triple
 **************************************************************/
function findHiddenPairOrTriple(){
  // 同理，只演示行内"Hidden Pair"
  for(let r=0;r<9;r++){
    // 统计某行内 (digit => 哪些格可放)
    let digitPositions={};
    for(let d=1;d<=9;d++){
      digitPositions[d]=[];
    }
    let empties=[];
    for(let c=0;c<9;c++){
      if(puzzleGrid[r][c]===0){
        empties.push({r,c});
        for(let d of candidatesGrid[r][c]){
          digitPositions[d].push({r,c});
        }
      }
    }
    // 找 hidden pair => 两个数字 只出现在同两个格
    for(let d1=1; d1<=9; d1++){
      for(let d2=d1+1; d2<=9; d2++){
        let pos1=digitPositions[d1], pos2=digitPositions[d2];
        if(pos1.length===2 && pos2.length===2 && samePositions(pos1,pos2)){
          // 说明 d1/d2只能出现在这两个格子 => hidden pair
          return {
            technique:"Hidden Pair",
            message:`第${r+1}行: 数字${d1}和${d2}只出现于同2格 => Hidden Pair`,
            digits:[d1,d2],
            cells: pos1
          };
        }
      }
    }
  }
  return null;
}
function samePositions(p1, p2){
  if(p1.length!==p2.length) return false;
  return p1.every((v,i)=> v.r===p2[i].r && v.c===p2[i].c);
}

/**************************************************************
 * 2.5 Box-Line 排除 (Pointing Pairs)
 **************************************************************/
function findBoxLineElimination(){
  // 类似之前的"Pointing Pairs"例子
  // 这里仅简单示意
  for(let boxR=0; boxR<3; boxR++){
    for(let boxC=0; boxC<3; boxC++){
      let startR=boxR*3, startC=boxC*3;
      let digitPositions={};
      for(let d=1;d<=9;d++){digitPositions[d]=[];}
      // 收集
      for(let rr=0; rr<3; rr++){
        for(let cc=0; cc<3; cc++){
          let r=startR+rr, c=startC+cc;
          if(puzzleGrid[r][c]===0){
            for(let d of candidatesGrid[r][c]){
              digitPositions[d].push({r,c});
            }
          }
        }
      }
      // 检测
      for(let d=1; d<=9; d++){
        let arr=digitPositions[d];
        if(arr.length>0 && arr.length<=3){
          let sameRow=arr.every(p=> p.r===arr[0].r);
          let sameCol=arr.every(p=> p.c===arr[0].c);
          if(sameRow){
            let rowIdx=arr[0].r;
            // ...
            return {
              technique:"Box-Line 排除",
              message:`第${boxR+1}宫,数字${d}仅位于同一行 => 可在此行其他宫格排除${d}`,
              digit:d,
              cells:arr
            };
          }else if(sameCol){
            let colIdx=arr[0].c;
            // ...
            return {
              technique:"Box-Line 排除",
              message:`第${boxC+1}宫,数字${d}仅位于同一列 => 可在此列其他宫格排除${d}`,
              digit:d,
              cells:arr
            };
          }
        }
      }
    }
  }
  return null;
}

/**************************************************************
 * 2.6 X-Wing
 **************************************************************/
function findXWing(){
  // 仅示意"行式X-Wing"
  // 对某数字 d, 找到两行, each行 d只可能出现在同2列
  for(let d=1; d<=9; d++){
    // 收集行内可能列
    let rowPossibleCols=Array.from({length:9},()=>[]);
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        if(puzzleGrid[r][c]===0 && candidatesGrid[r][c].has(d)){
          rowPossibleCols[r].push(c);
        }
      }
    }
    // 两行 => same 2 cols => X-Wing
    let rows = [];
    for(let r=0;r<9;r++){
      if(rowPossibleCols[r].length===2) rows.push(r);
    }
    // 任意两行 => colset相同
    for(let i=0;i<rows.length-1;i++){
      for(let j=i+1;j<rows.length;j++){
        let r1=rows[i], r2=rows[j];
        let colset1=rowPossibleCols[r1], colset2=rowPossibleCols[r2];
        if(colset1.length===2 && colset2.length===2 && sameArray(colset1,colset2)){
          return {
            technique:"X-Wing",
            message:`数字${d}在行${r1+1}与行${r2+1}中只出现于同2列 => 构成X-Wing`,
            digit:d,
            lines:[r1,r2],
            columns:colset1
          };
        }
      }
    }
  }
  return null;
}
function sameArray(a,b){ 
  if(a.length!==b.length) return false;
  return a.every((v,i)=>v===b[i]);
}

/**************************************************************
 * 2.7 XY-Wing
 **************************************************************/
function findXYWing() {
  // XY-Wing: A(\{x,y\}), B(\{x,z\}), C(\{y,z\})
  let empties = [];
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (puzzleGrid[r][c] === 0) {
        empties.push({ r, c, cands: [...candidatesGrid[r][c]] });
      }
    }
  }
  for (let i = 0; i < empties.length; i++) {
    for (let j = 0; j < empties.length; j++) {
      for (let k = 0; k < empties.length; k++) {
        if (i !== j && j !== k && i !== k) {
          let A = empties[i], B = empties[j], C = empties[k];
          if (A.cands.length === 2 && B.cands.length === 2 && C.cands.length === 2) {
            if (A.cands.has(C.cands[0]) && B.cands.has(C.cands[1])) {
              return {
                technique: "XY-Wing",
                message: "XY-Wing 适用",
                cells: [A, B, C],
                digits: [A.cands[0], B.cands[1]]
              };
            }
          }
        }
      }
    }
  }
  return null;
}

function findSwordfish() {
  for (let d = 1; d <= 9; d++) {
    // 检查数字 d 在行和列中出现的模式
    let rowCols = Array.from({ length: 9 }, () => []); // 存储每行的候选列
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        if (puzzleGrid[r][c] === 0 && candidatesGrid[r][c].has(d)) {
          rowCols[r].push(c);
        }
      }
    }

    // 检查是否有三行，且每行候选列交点构成矩阵
    for (let i = 0; i < 9; i++) {
      for (let j = i + 1; j < 9; j++) {
        for (let k = j + 1; k < 9; k++) {
          let commonCols = intersection(rowCols[i], rowCols[j], rowCols[k]);
          if (commonCols.length === 2) {
            return {
              technique: "Swordfish",
              message: `在行${i+1}, ${j+1}, ${k+1}中，数字${d}只能出现在这两列: ${commonCols.join(', ')}，可以排除该数字在其他行/列中的候选。`,
              digit: d,
              rows: [i, j, k],
              columns: commonCols
            };
          }
        }
      }
    }
  }
  return null;
}

// 用于查找交集的辅助函数
function intersection(arr1, arr2, arr3) {
  return arr1.filter(value => arr2.includes(value) && arr3.includes(value));
}

function findJellyfish() {
  for (let d = 1; d <= 9; d++) {
    let rowCols = Array.from({ length: 9 }, () => []);
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        if (puzzleGrid[r][c] === 0 && candidatesGrid[r][c].has(d)) {
          rowCols[r].push(c);
        }
      }
    }

    for (let i = 0; i < 9; i++) {
      for (let j = i + 1; j < 9; j++) {
        for (let k = j + 1; k < 9; k++) {
          for (let l = k + 1; l < 9; l++) {
            let commonCols = intersection(rowCols[i], rowCols[j], rowCols[k], rowCols[l]);
            if (commonCols.length === 3) {
              return {
                technique: "Jellyfish",
                message: `在行${i+1}, ${j+1}, ${k+1}, ${l+1}中，数字${d}只能出现在这三列: ${commonCols.join(', ')}，可以排除该数字在其他行/列中的候选。`,
                digit: d,
                rows: [i, j, k, l],
                columns: commonCols
              };
            }
          }
        }
      }
    }
  }
  return null;
}

function findXYZWing() {
  // 1. 找出所有候选数size=3的空格 => 可能是Pivot
  let pivotCandidates = [];
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (puzzleGrid[r][c] === 0) {
        let cands = candidatesGrid[r][c];
        if (cands.size === 3) {
          pivotCandidates.push({ r, c, cands: [...cands] }); 
          // cands: Array of 3 distinct digits
        }
      }
    }
  }

  // 2. 对于每个Pivot，找 Wing1/Wing2
  for (let pivot of pivotCandidates) {
    let [x, y, z] = pivot.cands; 
    // pivotCandidates只保证size=3，但不确定顺序
    // 不妨把 pivot.cands 全排列(3!)枚举, 以 x,y,z 形式
    // 这里做简化写法
    
    // 查找能见Pivot的格子 => Potential wing
    let visibleCells = getAllCellsVisibleTo(pivot.r, pivot.c);

    // 将可见格子分类：看谁候选包含 exactly 2个数字 & 这2个数字与 pivot.cands 有交集
    let twoCandidateCells = [];
    for (let cell of visibleCells) {
      let rr = cell.r, cc = cell.c;
      if (puzzleGrid[rr][cc] === 0) {
        let s = candidatesGrid[rr][cc];
        if (s.size === 2) {
          twoCandidateCells.push({
            r: rr, c: cc, cands: [...s]
          });
        }
      }
    }

    // 枚举 Wing1 / Wing2
    // Wing1: 2数字与 pivot 共享 2个
    // Wing2: 2数字与 pivot 共享 2个(但与Wing1不同)
    for (let i = 0; i < twoCandidateCells.length; i++) {
      for (let j = i+1; j < twoCandidateCells.length; j++) {
        let wing1 = twoCandidateCells[i];
        let wing2 = twoCandidateCells[j];
        // wing1 & pivot must share 2 of pivot's 3 cands
        // wing2 & pivot must share 2 (and 1 digit is the 'z')
        // wing1 & wing2 不可见
        let s1 = new Set(wing1.cands);
        let s2 = new Set(wing2.cands);
        let spivot = new Set(pivot.cands);

        // check intersection
        let pivotWing1 = intersectionSet(spivot, s1);
        let pivotWing2 = intersectionSet(spivot, s2);

        if (pivotWing1.size === 2 && pivotWing2.size === 2) {
          // Wing1 与 Wing2 不可见
          if (!areCellsVisible(wing1.r, wing1.c, wing2.r, wing2.c)) {
            // => 确认这是一个 XYZ-Wing
            // pivot中多出的那个数字(= spivot - pivotWing1?) 即 z
            let union12 = new Set([...pivotWing1, ...pivotWing2]);
            // pivotCands = x,y,z => union12 = 2 of them => leftover 1 is 'z'
            let leftover = differenceSet(spivot, union12); 
            if (leftover.size === 1) {
              let zVal = leftover.values().next().value;
              // => 说明Pivot可能填zVal, Wing1+Wing2 => ...
              // => 可以在Pivot可见的其它格子里排除zVal

              // 找"Pivot可见+Wing1或Wing2可见"的格子
              let eliminationCells = getCellsVisibleToBothWings(pivot, wing1, wing2);

              return {
                technique: "XYZ-Wing",
                message: `
                  XYZ-Wing: Pivot格(r${pivot.r+1},c${pivot.c+1})拥有候选${pivot.cands.join(',')}，
                  Wing1(r${wing1.r+1},c${wing1.c+1})=${wing1.cands.join(',')}，Wing2(r${wing2.r+1},c${wing2.c+1})=${wing2.cands.join(',')}。
                  由于Wing1与Wing2互不可见，但Pivot同时可见，
                  无论Pivot是否填${zVal}，都可在Pivot可见的其它格上排除${zVal}。
                `,
                cells: [
                  { r: pivot.r, c: pivot.c },
                  { r: wing1.r, c: wing1.c },
                  { r: wing2.r, c: wing2.c }
                ],
                digit: zVal,
                elimination: eliminationCells
              };
            }
          }
        }
      }
    }
  }
  return null; // 未找到
}

/** getAllCellsVisibleTo(r,c): 返回与 (r,c) 同行、同列、同宫的所有格 */
function getAllCellsVisibleTo(r, c) {
  let visible = [];
  // 行
  for (let cc = 0; cc < 9; cc++) {
    if (cc !== c) visible.push({ r, c: cc });
  }
  // 列
  for (let rr = 0; rr < 9; rr++) {
    if (rr !== r) visible.push({ r: rr, c });
  }
  // 宫
  let boxR = Math.floor(r/3)*3, boxC = Math.floor(c/3)*3;
  for (let rr = 0; rr < 3; rr++) {
    for (let cc = 0; cc < 3; cc++) {
      let R2 = boxR+rr, C2 = boxC+cc;
      if (!(R2===r && C2===c)) {
        visible.push({ r:R2, c:C2 });
      }
    }
  }
  // 去重
  // ...
  return uniqueCells(visible);
}

/** 判断两个格子是否可见(同行、同列、同宫) */
function areCellsVisible(r1,c1, r2,c2) {
  if (r1===r2) return true;
  if (c1===c2) return true;
  let box1r = Math.floor(r1/3), box1c = Math.floor(c1/3);
  let box2r = Math.floor(r2/3), box2c = Math.floor(c2/3);
  return (box1r===box2r && box1c===box2c);
}

/** getCellsVisibleToBothWings(...) => 需要再设计, 这里仅示意 */
function getCellsVisibleToBothWings(pivot, w1, w2) {
  // 例如：找所有既可见Pivot、又在Pivot"同时可见范围"内 => potential elimination
  return []; // 仅示意
}

/** 工具函数 */
function intersectionSet(a, b) {
  let res = new Set();
  for (let x of a) {
    if (b.has(x)) res.add(x);
  }
  return res;
}
function differenceSet(a, b) {
  let res = new Set(a);
  for (let x of b) {
    res.delete(x);
  }
  return res;
}
function uniqueCells(arr) {
  // arr 里可能重复 => 做set
  let map = {};
  let out = [];
  for (let cell of arr) {
    let key = cell.r+"_"+cell.c;
    if (!map[key]) {
      map[key] = true;
      out.push(cell);
    }
  }
  return out;
}

function findALS() {
  // 仅做非常简化示例: 在同一行内，找 n 个格子总共有 n+1 种候选 => 构成ALS
  // 然后看是否能通过 "XZ"链接 排除某个数字
  for (let r=0; r<9; r++) {
    // 收集本行空格
    let empties = [];
    for (let c=0; c<9; c++) {
      if (puzzleGrid[r][c]===0) {
        empties.push({ r,c, cands: [...candidatesGrid[r][c]] });
      }
    }
    // 枚举所有子集 => 看 subSet 里总格数 = n, 总候选 = n+1
    let allSubsets = getAllSubsets(empties);
    for (let subset of allSubsets) {
      let totalCandidates = new Set();
      for (let cell of subset) {
        for (let d of cell.cands) totalCandidates.add(d);
      }
      let n = subset.length;
      if (totalCandidates.size=== (n+1)) {
        // 这是一个ALS
        // => 需要找 "外部链接"，比如某digit Z 只在 ALS 里 1 or 2 次?
        // 这里仅做演示
        return {
          technique: "ALS",
          message: `在第${r+1}行找到一个ALS: ${n}个格包含${n+1}个候选`,
          cells: subset.map(c => ({r:c.r, c:c.c})),
          digits: [...totalCandidates]
        };
      }
    }
  }
  return null;
}

/** getAllSubsets(arr): 返回arr所有子集(实际中需做剪枝, 否则可能非常慢) */
function getAllSubsets(arr) {
  let results = [];
  let n = arr.length;
  let total = 1<<n; // 2^n
  for (let mask=1; mask<total; mask++) {
    let subset=[];
    for (let i=0;i<n;i++){
      if ( (mask & (1<<i)) !==0 ) {
        subset.push(arr[i]);
      }
    }
    results.push(subset);
  }
  return results;
}
function findDoubleChains() {
  // 1. 找所有只剩2个候选的格子 => 可能的链起点
  let twoCandidateCells = [];
  for (let r=0; r<9; r++){
    for (let c=0; c<9; c++){
      if (puzzleGrid[r][c]===0 && candidatesGrid[r][c].size===2){
        twoCandidateCells.push({ r,c, cands:[...candidatesGrid[r][c]] });
      }
    }
  }

  // 2. 构建简单的"可见图" => 若两格可见且共享某数字 => 用来做"排除推理"
  // 这里只是示意，真正的双链需要更多复杂的"若X则不Y"搜索
  for (let i=0;i<twoCandidateCells.length;i++){
    for(let j=i+1;j<twoCandidateCells.length;j++){
      let cellA=twoCandidateCells[i], cellB=twoCandidateCells[j];
      if (areCellsVisible(cellA.r,cellA.c, cellB.r,cellB.c)){
        // 看是否能形成某条链 => e.g. they share a digit => 可能产生冲突
        let setA=new Set(cellA.cands), setB=new Set(cellB.cands);
        let common=intersectionSet(setA,setB);
        if(common.size===1){
          // 说明他们共享1个数字 => potential chain
          let digit=[...common][0];
          // ... 这里需要做更多"假设digit =>..." 推理

          // 在真正的双链实现中，会深度DFS:
          //   "假设 cellA= digit => then cellB!= digit => cause ..." 
          //   或 "cellA != digit => then cellB= digit => cause ..."
          // 如果发现矛盾 => 说明可排除
          // 这里只做示意

          return {
            technique:"DoubleChains",
            message: `
              发现二元链起点: (r${cellA.r+1},c${cellA.c+1}) 与 (r${cellB.r+1},c${cellB.c+1}) 
              共享数字 ${digit}。可尝试"若A填digit => B不填digit => ..."做链式推理。`,
            cells: [ {r: cellA.r, c: cellA.c}, {r: cellB.r, c: cellB.c} ],
            digit
          };
        }
      }
    }
  }
  return null;
}

// 需要areCellsVisible, intersectionSet等辅助
function areCellsVisible(r1,c1,r2,c2){
  // 同行 or 同列 or 同宫
  if(r1===r2) return true;
  if(c1===c2) return true;
  let box1r=Math.floor(r1/3), box1c=Math.floor(c1/3);
  let box2r=Math.floor(r2/3), box2c=Math.floor(c2/3);
  return (box1r===box2r && box1c===box2c);
}
function intersectionSet(a,b){
  let res=new Set();
  for(let x of a){
    if(b.has(x)) res.add(x);
  }
  return res;
}

/**************************************************************
 * 3. UI: 显示提示(高亮相关格)
 **************************************************************/
function showHint(hint){
  let msgBox=document.getElementById('hint-msg');
  if(!hint){
    msgBox.textContent="暂无可用技巧，需更高级思路或已无解。";
    return;
  }
  // 显示
  msgBox.textContent=`[${hint.technique}] ${hint.message}`;
  highlightCells(hint.cells || []);
}
document.getElementById('fill-candidates').addEventListener('click', ()=>{
  computeAllCandidates(); // 全量计算
  renderCandidates();     // 显示
});
/** 数字按钮 => onNumberInput */
document.querySelectorAll('.num-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    if(!selectedCell) return; // 没有选中格子时，什么都不做(也可自行改成点亮逻辑)
    let num=parseInt(btn.dataset.num,10);
    onNumberInput(num);
  });
});
document.getElementById('btn-hint').addEventListener('click',()=>{
  let hint=getHint();
  showHint(hint);
});
/** 键盘 1~9 => onNumberInput */
document.addEventListener('keydown',(e)=>{
  if(e.key>='1' && e.key<='9'){
    if(!selectedCell) return; // 同上
    onNumberInput(parseInt(e.key,10));
  }
});

/** 页面初始化：先创建空表 */
createBoardCells();
</script>
</body>
</html>
